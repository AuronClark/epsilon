#include <triangle.cl>
#include <geometry.cl>
#include <camera.cl>
#include <prng.cl>

const sampler_t sampler = CLK_NORMALIZED_COORDS_TRUE |
						  CLK_ADDRESS_CLAMP_TO_EDGE  |
                          CLK_FILTER_LINEAR;

typedef struct Light
{
	float3 position;
	int material;
} Light;

typedef struct __attribute__ ((packed)) Scene
{
	uint4 res;
} Scene;

float Intersect(global Triangle *geometry, float3 origin, float3 direction,
                int *hit)
{
    float min_t = INFINITY;
    int closest = -1;

    for (int i = 0; i < 12; ++i)
    {
        float dist;
        if (RayTriangle(origin, direction, geometry[i], &dist))
        {
            if (dist < min_t)
            {
                min_t = dist;
                closest = i;
            }
        }
    }

    if (closest != -1) *hit = closest;
    return min_t;
};

/* geometry: the entire list of triangles in the scene.
 * 


*/
void kernel clmain(global float4 *render, /* Render buffer in XYZn format. */
	     		   global Triangle *geometry, /* List of triangles in scene. */
                   //global BVHNode *bvhNodes, /* List of BVH nodes in scene. */
                   //global Model *model, /* List of models in scene. */
                   //global ModelNode *modelNodes, /* Model BVH structure. */
				   //global Light *lights, /* List of light sources. */
                   read_only image1d_array_t surface, /* Surface materials.. */
                   //read_only image1d_array_t volume, /* Volume materials. */
				   constant ulong4 *seed, /* Seed for the PRNG. */
				   read_only image1d_t spectrum, /* Color-matching function. */
				   constant Scene *scene, /* Scene information. */
                   constant Camera *camera /* Camera information. */
                   )
{
	/* Get a PRNG instance for this worker. */
    PRNG prng = init(get_global_id(0), seed);

    /* Get pixel coordinates in normalized coordinates [0..1). */
    float a1 = rand(&prng) - 0.5f;
    float a2 = rand(&prng) - 0.5f;

	float x = (float)(a1 + get_global_id(0) % scene->res.x) / scene->res.x;
	float y = (float)(a2 + get_global_id(0) / scene->res.x) / scene->res.y;

    // render[get_global_id(0)] = (float4)(read_imagef(surface, sampler,
    //                                       (float2)(x, 0)).x, 0, 0, 1.0f);
    //return;

    /* Compute the standard camera ray. */
    float3 origin, direction;
    Trace(x, y, &origin, &direction, camera);

    /* Select random wavelength. */
    float wavelength = rand(&prng);

    /* Repeat until we die. */
    float radiance = 0.0f;
    while (true)
    {
        int hit = -1;
        Triangle tri;
        float t = Intersect(geometry, origin, direction, &hit);
        if (hit == -1)
        {
            radiance = 0.0f;
            break;
        }

        tri = geometry[hit];

        float3 point = origin + t * direction;

        /* Check material for light! */
        if (tri.mat < 0)
        {
            /* This is a light. */
            radiance = 10.0f;
            break;
        }

        /* Get normal. */
        float3 normal = tri.n;
        normal = normal * sign(-dot(normal, direction));

        /* Otherwise, apply response curve. */
        float response = read_imagef(surface, sampler,
                                     (float2)(wavelength,
                                              tri.mat)).x;

        /* Get a random diffuse sample. */
        float u1 = rand(&prng);
        float u2 = rand(&prng);
        float theta = 2.0f * 3.149159265 * u2;
        float r = sqrt(u1);

        float3 newdir = (float3)(r * cos(theta), sqrt(1.0f - u1), r * sin(theta));

        /* Rotate according to basis. */
        float3 basisY = normal;
        float3 UP = normalize((float3)(0.01, 0.99, 0.01));
        float3 basisX = normalize(cross(basisY, UP));
        float3 basisZ = normalize(cross(basisX, basisY));
        newdir = newdir.x * basisX
               + newdir.y * basisY
               + newdir.z * basisZ;

        radiance = response;                      
        
        if (rand(&prng) > radiance)
        {
            radiance = 0.0f;
            break;
        }

        /* Else continue. */
        origin = point + normal * 0.01f;
        direction = newdir;
    }

    float3 xyz = radiance * read_imagef(spectrum, sampler, wavelength).xyz;

    render[get_global_id(0)] += (float4)(xyz, radiance);

    return;

    #if 0

    /* Intersect ray with triangles. */
    float min_t = INFINITY;
    int closest = -1;
    
    for (int i = 0; i < 3; ++i)
    {
        float dist;
        if (RayTriangle(origin, direction, geometry[i], &dist))
        {
            if (dist < min_t)
            {
                min_t = dist;
                closest = i;
            }
        }
    }

    /* Output a color if intersected. */
    if (closest == -1) render[get_global_id(0)] = (float4)(0, 0, 0, 1);
    if (closest == 0)  render[get_global_id(0)] = (float4)(0, 1, 0, 1);
    if (closest == 1)  render[get_global_id(0)] = (float4)(u1, 0, 0, 1);
    if (closest == 2)  render[get_global_id(0)] = (float4)(0, 0, u2, 1);
    return;

    /* Output some stuff. */
    render[get_global_id(0)] = (float4)((direction.x + 1) * 0.5,
                                        (direction.y + 1) * 0.5,
                                        (direction.z + 1) * 0.5, 1);

    #endif

	// render[get_global_id(0)] = (float4)(y, 0, x, 1);

	#if 0

    /* Get pixel position, etc... */
    float3 origin = ...;
    float3 direction = ...;

    /* Prepare the material stack. */
    int matStack[16];
    int matCount = 0;
    
    /* Path tracing. */
    while (true)
    {
        /* Find intersection distance to the nearest triangle. */
        float t;
        if (!Intersection(origin, direction, &t, ...))
        {
            /* No intersection, just return black. */
            ... 0.0f 
            return;
        }

		/* Read the material properties of the material we're currently in. */
		float2 matIndex = (float2)(lambda, matStack[matCount]);
		float4 mt1 = read_imagef(materials, sampler, matIndex);
        
        /* Otherwise, use probability distribution ke^tk to decide whether the
         * ray will make it to that triangle without getting scattered. */
        // do stuff here...
        if (makes it)
        {
            /* First, check if the intersected triangle is a light source, if
             * it is, we are done and just return that. */
            if (is light source)
            {
                ... radiantEmittance(lambda);
                return;
            }

            /* Use fresnel equations (using material settings) to decide if
             * ray should be refracted or reflected, handle interference and
             * update material stack in case of refraction. */
            fresnel equations here

			/* Layer resolution here. */

			if (transmitted)
			{
				/* Did we intersect the material we were already in? */
			}
			else
			{
				/* Reflected, we're done. */
			}
        }
        else
        {
            /* Scatter the ray, using the material's phase function. Do not
             * update the material stack as there is no medium change. */
            phase function scattering here

			/* Go over each light and direct-sample it with an intersection test,
			 * taking into account the phase function's PDF. */
        }

        /* Russian roulette here. Note radiance is subcritical. */
        if (u > radiance)
        {
            /* Return zero. */
            ... 0.0f
            return;
        }

        /* Otherwise, go for one more bounce. */
    }
	#endif
}
